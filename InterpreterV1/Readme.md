# Интерпретатор учебного языка **AkramovLang++**

## 1. Назначение проекта

Учебный проект демонстрирует полный цикл реализации простого интерпретируемого языка программирования: лексический анализ, синтаксический и семантический анализ с построением ПОЛИЗ (постфиксной формы записи), а также исполнение полученного ПОЛИЗа на стековой виртуальной машине. Проект предназначен для лабораторных работ и курсов по теории языков программирования, компиляторам и системному программированию.

## 2. Структура репозитория

```
.
├── bin/          # каталог для исполняемых файлов (создаётся при сборке)
├── build/        # объектные файлы, временные артефакты компиляции
├── data/         # примеры программ‑тестов
├── include/
│   └── interpreter.h  # общие типы, объявления классов и функций
├── src/          # исходный код, распределённый по модулям
│   ├── lexer.cpp      # лексический анализатор
│   ├── parser.cpp     # синтаксический анализ + семантика
│   ├── poliz.cpp      # генерация ПОЛИЗ
│   ├── executor.cpp   # стековая машина для исполнения ПОЛИЗ
│   └── main.cpp       # точка входа
└── Makefile      # сценарий сборки (GNU make, C++17)
```

## 3. Сборка и запуск

```bash
# сборка проекта
make

# запуск интерпретатора с конкретным файлом программы
bin/interpreter data/testProg1.txt

# запуск всех тестовых программ в каталоге data/
make test

# полная очистка артефактов
make clean
```

Переменная окружения `PROGRAM` позволяет передать путь к произвольному файлу программы:

```bash
PROGRAM=myProgram.txt make run
```

## 4. Краткое описание языка MiniLang++

### 4.1 Типы данных

| Тип      | Описание                         |
| -------- | -------------------------------- |
| `int`    | Целые числа (32‑битовые)         |
| `real`   | Числа с плавающей точкой         |
| `bool`   | Логические значения `true/false` |
| `string` | Строки в двойных кавычках        |

### 4.2 Ключевые слова

`program`, `if`, `else`, `for`, `while`, `goto`, `continue`, `break`, `read`, `write`, `true`, `false`, а также имена типов (`int`, `real`, `bool`, `string`).

### 4.3 Лексические элементы

* **Идентификатор** — регулярное выражение `[A‑Za‑z_][A‑Za‑z0‑9_]*`.
* **Числовые литералы** — целые (`123`) или вещественные (`3.14`).
* **Строковые литералы** — текст в двойных кавычках с поддержкой `\n`, `\t` и других стандартных escape‑последовательностей.
* **Комментарии** — однострочные, начинаются с `#` и длятся до конца строки.

### 4.4 Операторы и приоритеты

| Приоритет (от высшего к низшему) | Операция                 |
| -------------------------------- | ------------------------ |
| 1                                | Унарные `+  -  not`      |
| 2                                | `*  /  %`                |
| 3                                | `+  -`                   |
| 4                                | Сравнения `<  >  <=  >=` |
| 5                                | Равенство `==  !=`       |
| 6                                | Логическое *and*         |
| 7                                | Логическое *or*          |
| 8                                | Присваивание `=  +=  -=` |

### 4.5 Контекстно‑свободная грамматика (EBNF)

```ebnf
program        ::= 'program' '{' decl_list? stmt_list? '}' ;

decl_list      ::= decl { decl } ;

decl           ::= type id_list ';' ;

type           ::= 'int' | 'real' | 'bool' | 'string' ;

id_list        ::= identifier { ',' identifier } ;

stmt_list      ::= stmt { stmt } ;

stmt           ::= compound
                | expr ';'
                | 'if' '(' expr ')' stmt [ 'else' stmt ]
                | 'while' '(' expr ')' stmt
                | 'for' '(' expr? ';' expr? ';' expr? ')' stmt
                | 'goto' identifier ';'
                | 'continue' ';'
                | 'break' ';'
                | 'read'  '(' identifier ')' ';'
                | 'write' '(' expr { ',' expr } ')' ';'
                | identifier ':' stmt ;

compound       ::= '{' stmt_list? '}' ;

expr           ::= assign ;
assign         ::= logic_or { ( '=' | '+=' | '-=' ) assign } ;
logic_or       ::= logic_and { 'or' logic_and } ;
logic_and      ::= equality { 'and' equality } ;
equality       ::= rel { ( '==' | '!=' ) rel } ;
rel            ::= add { ( '<' | '>' | '<=' | '>=' ) add } ;
add            ::= mul { ( '+' | '-' ) mul } ;
mul            ::= unary { ( '*' | '/' | '%' ) unary } ;
unary          ::= ( '+' | '-' | 'not' ) unary
                | primary ;
primary        ::= identifier | literal | '(' expr ')' ;
```

### 4.6 Семантические правила

* Строгая статическая типизация; неявные преобразования выполняются только между `int` и `real` в арифметических выражениях.
* Оператор `string + string` выполняет конкатенацию.
* `goto` осуществляет переход к метке; наличие метки проверяется на этапе разбора.
* `read()` и `write()` работают со стандартным потоком ввода‑вывода, проверяя корректность типов аргументов.

## 5. Внутренняя архитектура

1. **Лексер** преобразует входной текст в поток токенов.
2. **Парсер** и **семантический анализатор** строят ПОЛИЗ, одновременно формируя таблицы символов и проверяя типы.
3. **Исполнитель** обрабатывает ПОЛИЗ при помощи стековой виртуальной машины.

## 6. Тестирование

Каталог `data/` содержит шесть демонстрационных программ, покрывающих основные конструкции языка. Команда `make test` компилирует проект (при необходимости) и запускает интерпретатор последовательно на каждом тестовом файле, выводя результаты выполнения.

## 7. Возможные направления расширения

* Поддержка дополнительных типов (`char`, массивы, словари).
* Функции пользователя и стек вызовов.
* REPL‑режим (интерактивный интерпретатор).


---

*Автор: Роман Акрамов*
