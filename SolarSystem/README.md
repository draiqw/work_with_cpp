# N‑Body Solar System Simulator

> Чистый C++‑17 проект, реализующий численно‑инвариантное интегрирование (вариант "kick‑drift‑kick" leapfrog) для модели Солнечной системы.

## 1. Быстрый старт

```bash
# Клонируйте/распакуйте проект и перейдите в корневую папку
make               # сборка основного бинарника bin/solver
make test          # сборка и запуск теста bin/test

# Пример обычного запуска
make run ARGS="data/ 15.08.2025 1e-9 86400"
#              └───  ──────────  ──── ─────
#              │       │         │     │
#              │       │         └──────── начальный шаг интегрирования (dt_init) в секундах
#              │       │────────────────── относительная точность ε_rel
#              │───────────────────────── целевая дата DD.MM.YYYY (должна быть ≥ эпохе)
#              └──────────────────────── каталог с данными тел
```

### Отладочный режим

```bash
make debugrun ARGS="data 14.02.2026 1e-9 43200"
# добавляет -g и -DDEBUG, выводит подробную диагностику каждого 100‑го шага
```

## 2. Зависимости

* **g++ 9+** с поддержкой C++17
* **make**
* Для Windows можно собирать в MSYS2/MinGW либо в Visual Studio (создайте проект и подключите исходники/заголовки самостоятельно).

## 3. Makefile: цели и варианты запуска

| Цель             | Описание                                                                               |
| ---------------- | -------------------------------------------------------------------------------------- |
| `make`           | Сборка основного бинарника `bin/solver`.                                               |
| `make test`      | Сборка тестового бинарника `bin/test` и его запуск с параметрами из переменной `ARGS`. |
| `make run`       | Сборка (при необходимости) и запуск `bin/solver` с параметрами из `ARGS`.              |
| `make debugrun`  | Сборка с флагами отладки (`-g -DDEBUG`) и запуск `bin/solver` с параметрами из `ARGS`. |
| `make debugtest` | Сборка теста с флагами отладки и запуск `bin/test` с параметрами из `ARGS`.            |
| `make clean`     | Удаление всех объектов и бинарников (`build/` и `bin/`).                               |

Переменная `ARGS` задаётся в формате:

```
ARGS="<data_dir> <DD.MM.YYYY> <epsrel> <dt_init> [PlanetName]"
```

где:

* `<data_dir>` — каталог с исходными файлами тел (JPL HORIZONS).
* `<DD.MM.YYYY>` — целевая дата интегрирования (должна быть ≥ эпохе в файлах данных).
* `<epsrel>` — относительная точность по инвариантам (энергия, импульс, момент).
* `<dt_init>` — начальный шаг интегрирования в секундах.
* `[PlanetName]` — (только для теста) имя планеты для тестового бинарника (по умолчанию Earth).

## 4. Структура каталогов

```
project/
├── Makefile          # сценарии сборки и правила тестирования
├── include/          # заголовочные файлы *.h, *.hpp
├── src/              # исходники *.cpp
│   └── test.cpp      # минимальный функциональный тест (1 год орбиты)
├── bin/              # здесь появляются собранные бинарники
├── build/            # временные *.o и *.d
└── data/             # пример каталога с исходными файлами тел
```

## 5. Формат входных файлов

* Каждый файл — выгрузка из **JPL HORIZONS**.
* Обязательно содержит строки:

  * `A.D. YYYY‑Mon‑DD …`  — дата **эпохи** (служит t = 0).
  * `Mass (kg) = …`      — масса тела.
  * `X = … Y = … Z = …` — координаты (км) в эпоху.
  * `VX= … VY= … VZ= …` — скорости (км/с) в эпоху.
* Имя тела берётся из строки `Revised … <Name>`.

## 6. Запуск solver’а

```
./bin/solver <data_dir> <DD.MM.YYYY> <epsrel> <dt_init>
```

**Что делает программа**:

1. Загружает тела Солнечной системы из файлов в `<data_dir>`.
2. Парсит дату эпохи (t = 0) из первой встретившейся строки `A.D.`.
3. Переводит целевую дату `DD.MM.YYYY` в секунды от эпохи.
4. Строит начальные массивы масс, положений и скоростей.
5. Интегрирует систему методом leapfrog (kick‑drift‑kick) с адаптивным шагом `dt`, контролируя относительные изменения энергии, полного импульса и момента:

   * если инварианты сохраняются в пределах `epsrel`, шаг удваивается, иначе делится на два и повтор интегрирования текущего шага;
   * процесс идёт до тех пор, пока не будет достигнуто время `t_end`.
6. Выводит финальные положения и скорости всех тел.

При включённом `DEBUG`:

* выводится пошаговая эволюция энергии, импульсов и изменение шага каждые 100 шагов и в конце.

## 7. Тест "смещения планеты"

`make test` (или `make debugtest`) собирает и запускает **bin/test**:

* Интегрирует ровно 1 год для выбранной планеты (`PlanetName`, по умолчанию Earth).
* Сравнивает конечную позицию и скорость с начальными, выводит линейное смещение и относительное изменение энергии.

## 8. Единицы величин

* расстояния — **км**
* массы — **кг**
* время — **с**
* гравитационная константа `G = 6.67430e‑20 km³·kg⁻¹·s⁻²`

## 9. Внутреннее устройство

| Файл/класс               | Роль                                                                         |
| ------------------------ | ---------------------------------------------------------------------------- |
| `Vec3`                   | минимальный 3‑D вектор с арифметикой, скалярным/векторным произведением      |
| `SolarBody`              | масса, положение, скорость и имя одного объекта                              |
| `SolarSystem`            | хранит вектор тел, умеет читать каталог, считать энергию/импульсы, ускорения |
| `Integrator`             | алгоритм leapfrog (kick‑drift‑kick) с адаптивным dt по инвариантам           |
| `Utils::date_to_seconds` | перевод `DD.MM.YYYY` в секунды от эпохи                                      |

## 10. Логика программы (без кода)

Ниже описана структурная схема реализации симулятора, разделённая на функциональные блоки:

### 1. Чтение и парсинг данных

* По заданному каталогу (`data/`) считываем файлы тел (JPL HORIZONS).
* Для каждого файла извлекаем:

  * Массу (`Mass`).
  * Координаты (`X, Y, Z`).
  * Скорости (`VX, VY, VZ`).
  * Имя тела (`Revised ... <Name>`).
  * Эпоху (`A.D. YYYY-Mon-DD`).
* Заполняем структуры:

  * Вектор масс `m[i]`.
  * Вектор позиций `q[i]`.
  * Вектор скоростей `v[i]`.

### 2. Инициализация интегратора

* Пользователь вводит:

  * Целевую дату `DD.MM.YYYY`.
  * Относительная точность `epsrel`.
  * Начальный шаг `dt_init`.
* Переводим дату в секунды от эпохи (`t_end`).
* Устанавливаем текущее время `t = 0`.

### 3. Вычисление ускорений

* Для всех тел `i`:

  * `a[i] = -G * sum_{j != i}( m[j] * (q[i] - q[j]) / |q[i] - q[j]|^3 )`.

### 4. Шаг интеграции (Størmer–Verlet kick-drift-kick)

Повторять до `t >= t_end`:

1. **Kick (полушаг скорости)**

   * `v_half[i] = v[i] + a[i] * (dt / 2)`
2. **Drift (полный шаг позиции)**

   * `q_new[i] = q[i] + v_half[i] * dt`
3. **Вычислить новые ускорения**

   * `a_new[i] = compute_accelerations(q_new)`
4. **Kick (полушаг скорости)**

   * `v_new[i] = v_half[i] + a_new[i] * (dt / 2)`

### 5. Адаптивный выбор шага и проверка инвариантов

* После получения `(q_new, v_new)`:

  * Вычисляем новые инварианты:

    * Энергия `E_new`.
    * Полный импульс `P_new`.
    * Момент импульса `L_new`.
  * Сравниваем с предыдущими `(E_old, P_old, L_old)`:

    * Если любое относительное изменение > `epsrel`, то:

      * `dt /= 2` и повтор шага.
    * Иначе:

      * Принимаем шаг: `q = q_new`, `v = v_new`, `t += dt`.
      * При желании можно `dt *= 2` (ограничивая, чтобы не выйти за `t_end`).

### 6. Завершение и вывод результатов

* Как только `t` достигает `t_end`:

  * Текущие `q[i]` и `v[i]` — финальные положения и скорости.
* Выводим их в консоль или файл.
* (Опционально) Выводим историю инвариантов для анализа точности.
